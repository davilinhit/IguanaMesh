/*
 * Gmsh - Copyright (C) 1997-2020 C. Geuzaine, J.-F. Remacle
 *
 * See the LICENSE.txt file for license information. Please report all
 * issues on https://gitlab.onelab.info/gmsh/gmsh/issues.
 */

#ifndef GMSHC_H
#define GMSHC_H

/*
 * This file defines the Gmsh C API (v4.6).
 *
 * Do not edit it directly: it is automatically generated by `api/gen.py'.
 *
 * By design, the Gmsh C API is purely functional, and only uses elementary
 * C types. See `tutorial/c' and `demos/api' for examples.
 */

#include <stddef.h>

#define GMSH_API_VERSION "4.6"
#define GMSH_API_VERSION_MAJOR 4
#define GMSH_API_VERSION_MINOR 6

#if defined(GMSH_DLL)
#if defined(GMSH_DLL_EXPORT)
#define GMSH_API __declspec(dllexport)
#else
#define GMSH_API __declspec(dllimport)
#endif
#else
#define GMSH_API
#endif



/* List the names of all models. */
GMSH_API void gmshModelList(char *** names, size_t * names_n,
                            int * ierr);



/* Evaluate the parametrization of the entity of dimension `dim' and tag `tag'
 * at the parametric coordinates `parametricCoord'. Only valid for `dim' equal
 * to 0 (with empty `parametricCoord'), 1 (with `parametricCoord' containing
 * parametric coordinates on the curve) or 2 (with `parametricCoord'
 * containing pairs of u, v parametric coordinates on the surface,
 * concatenated: [p1u, p1v, p2u, ...]). Return triplets of x, y, z coordinates
 * in `coord', concatenated: [p1x, p1y, p1z, p2x, ...]. */
GMSH_API void gmshModelGetValue(const int dim,
                                const int tag,
                                double * parametricCoord, size_t parametricCoord_n,
                                double ** coord, size_t * coord_n,
                                int * ierr);


/* Get the parametric coordinates `parametricCoord' for the points `coord' on
 * the entity of dimension `dim' and tag `tag'. `coord' are given as triplets
 * of x, y, z coordinates, concatenated: [p1x, p1y, p1z, p2x, ...].
 * `parametricCoord' returns the parametric coordinates t on the curve (if
 * `dim' = 1) or pairs of u and v coordinates concatenated on the surface (if
 * `dim' = 2), i.e. [p1t, p2t, ...] or [p1u, p1v, p2u, ...]. */
GMSH_API void gmshModelGetParametrization(const int dim,
                                          const int tag,
                                          double * coord, size_t coord_n,
                                          double ** parametricCoord, size_t * parametricCoord_n,
                                          int * ierr);

/* Get the `min' and `max' bounds of the parametric coordinates for the entity
 * of dimension `dim' and tag `tag'. */
GMSH_API void gmshModelGetParametrizationBounds(const int dim,
                                                const int tag,
                                                double ** min, size_t * min_n,
                                                double ** max, size_t * max_n,
                                                int * ierr);

/* Check if the parametric coordinates provided in `parametricCoord'
 * correspond to points inside the entitiy of dimension `dim' and tag `tag',
 * and return the number of points inside. This feature is only available for
 * a subset of curves and surfaces, depending on the underyling geometrical
 * representation. */
GMSH_API int gmshModelIsInside(const int dim,
                               const int tag,
                               double * parametricCoord, size_t parametricCoord_n,
                               int * ierr);

/* Get the points `closestCoord' on the entity of dimension `dim' and tag
 * `tag' to the points `coord', by orthogonal projection. `coord' and
 * `closestCoord' are given as triplets of x, y, z coordinates, concatenated:
 * [p1x, p1y, p1z, p2x, ...]. `parametricCoord' returns the parametric
 * coordinates t on the curve (if `dim' = 1) or pairs of u and v coordinates
 * concatenated on the surface (if `dim' = 2), i.e. [p1t, p2t, ...] or [p1u,
 * p1v, p2u, ...]. */
GMSH_API void gmshModelGetClosestPoint(const int dim,
                                       const int tag,
                                       double * coord, size_t coord_n,
                                       double ** closestCoord, size_t * closestCoord_n,
                                       double ** parametricCoord, size_t * parametricCoord_n,
                                       int * ierr);

/* Reparametrize the boundary entity (point or curve, i.e. with `dim' == 0 or
 * `dim' == 1) of tag `tag' on the surface `surfaceTag'. If `dim' == 1,
 * reparametrize all the points corresponding to the parametric coordinates
 * `parametricCoord'. Multiple matches in case of periodic surfaces can be
 * selected with `which'. This feature is only available for a subset of
 * entities, depending on the underyling geometrical representation. */
GMSH_API void gmshModelReparametrizeOnSurface(const int dim,
                                              const int tag,
                                              double * parametricCoord, size_t parametricCoord_n,
                                              const int surfaceTag,
                                              double ** surfaceParametricCoord, size_t * surfaceParametricCoord_n,
                                              const int which,
                                              int * ierr);

/* Set the visibility of the model entities `dimTags' to `value'. Apply the
 * visibility setting recursively if `recursive' is true. */
GMSH_API void gmshModelSetVisibility(int * dimTags, size_t dimTags_n,
                                     const int value,
                                     const int recursive,
                                     int * ierr);

/* Get the visibility of the model entity of dimension `dim' and tag `tag'. */
GMSH_API void gmshModelGetVisibility(const int dim,
                                     const int tag,
                                     int * value,
                                     int * ierr);


/* Get the last entities (if any) where a meshing error occurred. Currently
 * only populated by the new 3D meshing algorithms. */
GMSH_API void gmshModelMeshGetLastEntityError(int ** dimTags, size_t * dimTags_n,
                                              int * ierr);

/* Get the last nodes (if any) where a meshing error occurred. Currently only
 * populated by the new 3D meshing algorithms. */
GMSH_API void gmshModelMeshGetLastNodeError(size_t ** nodeTags, size_t * nodeTags_n,
                                            int * ierr);



/* Preallocate data before calling `getElementsByType' with `numTasks' > 1.
 * For C and C++ only. */
GMSH_API void gmshModelMeshPreallocateElementsByType(const int elementType,
                                                     const int elementTag,
                                                     const int nodeTag,
                                                     size_t ** elementTags, size_t * elementTags_n,
                                                     size_t ** nodeTags, size_t * nodeTags_n,
                                                     const int tag,
                                                     int * ierr);


/* Get the numerical quadrature information for the given element type
 * `elementType' and integration rule `integrationType' (e.g. "Gauss4" for a
 * Gauss quadrature suited for integrating 4th order polynomials).
 * `localCoord' contains the u, v, w coordinates of the G integration points
 * in the reference element: [g1u, g1v, g1w, ..., gGu, gGv, gGw]. `weights'
 * contains the associated weights: [g1q, ..., gGq]. */
GMSH_API void gmshModelMeshGetIntegrationPoints(const int elementType,
                                                const char * integrationType,
                                                double ** localCoord, size_t * localCoord_n,
                                                double ** weights, size_t * weights_n,
                                                int * ierr);


/* Preallocate data before calling `getJacobians' with `numTasks' > 1. For C
 * and C++ only. */
GMSH_API void gmshModelMeshPreallocateJacobians(const int elementType,
                                                const int numEvaluationPoints,
                                                const int allocateJacobians,
                                                const int allocateDeterminants,
                                                const int allocateCoord,
                                                double ** jacobians, size_t * jacobians_n,
                                                double ** determinants, size_t * determinants_n,
                                                double ** coord, size_t * coord_n,
                                                const int tag,
                                                int * ierr);



/* Preallocate data before calling `getBasisFunctionsOrientationForElements'
 * with `numTasks' > 1. For C and C++ only. */
GMSH_API void gmshModelMeshPreallocateBasisFunctionsOrientationForElements(const int elementType,
                                                                           int ** basisFunctionsOrientation, size_t * basisFunctionsOrientation_n,
                                                                           const int tag,
                                                                           int * ierr);

/* Get the global edge identifier `edgeNum' for an input list of node pairs,
 * concatenated in the vector `edgeNodes'.  Warning: this is an experimental
 * feature and will probably change in a future release. */
GMSH_API void gmshModelMeshGetEdgeNumber(int * edgeNodes, size_t edgeNodes_n,
                                         int ** edgeNum, size_t * edgeNum_n,
                                         int * ierr);

/* Get the local multipliers (to guarantee H(curl)-conformity) of the order 0
 * H(curl) basis functions. Warning: this is an experimental feature and will
 * probably change in a future release. */
GMSH_API void gmshModelMeshGetLocalMultipliersForHcurl0(const int elementType,
                                                        int ** localMultipliers, size_t * localMultipliers_n,
                                                        const int tag,
                                                        int * ierr);

/* Generate the `keys' for the elements of type `elementType' in the entity of
 * tag `tag', for the `functionSpaceType' function space. Each key uniquely
 * identifies a basis function in the function space. If `returnCoord' is set,
 * the `coord' vector contains the x, y, z coordinates locating basis
 * functions for sorting purposes. Warning: this is an experimental feature
 * and will probably change in a future release. */
GMSH_API void gmshModelMeshGetKeysForElements(const int elementType,
                                              const char * functionSpaceType,
                                              int ** keys, size_t * keys_n,
                                              double ** coord, size_t * coord_n,
                                              const int tag,
                                              const int returnCoord,
                                              int * ierr);

/* Get the keys for a single element `elementTag'. */
GMSH_API void gmshModelMeshGetKeysForElement(const size_t elementTag,
                                             const char * functionSpaceType,
                                             int ** keys, size_t * keys_n,
                                             double ** coord, size_t * coord_n,
                                             const int returnCoord,
                                             int * ierr);

/* Get the number of keys by elements of type `elementType' for function space
 * named `functionSpaceType'. */
GMSH_API int gmshModelMeshGetNumberOfKeysForElements(const int elementType,
                                                     const char * functionSpaceType,
                                                     int * ierr);


/* Preallocate data before calling `getBarycenters' with `numTasks' > 1. For C
 * and C++ only. */
GMSH_API void gmshModelMeshPreallocateBarycenters(const int elementType,
                                                  double ** barycenters, size_t * barycenters_n,
                                                  const int tag,
                                                  int * ierr);


/* Get the ghost elements `elementTags' and their associated `partitions'
 * stored in the ghost entity of dimension `dim' and tag `tag'. */
GMSH_API void gmshModelMeshGetGhostElements(const int dim,
                                            const int tag,
                                            size_t ** elementTags, size_t * elementTags_n,
                                            int ** partitions, size_t * partitions_n,
                                            int * ierr);


/* Set the meshes of the entities of dimension `dim' and tag `tags' as
 * periodic copies of the meshes of entities `tagsMaster', using the affine
 * transformation specified in `affineTransformation' (16 entries of a 4x4
 * matrix, by row). If used after meshing, generate the periodic node
 * correspondence information assuming the meshes of entities `tags'
 * effectively match the meshes of entities `tagsMaster' (useful for
 * structured and extruded meshes). Currently only available for @code{dim} ==
 * 1 and @code{dim} == 2. */
GMSH_API void gmshModelMeshSetPeriodic(const int dim,
                                       int * tags, size_t tags_n,
                                       int * tagsMaster, size_t tagsMaster_n,
                                       double * affineTransform, size_t affineTransform_n,
                                       int * ierr);

/* Get the master entity `tagMaster', the node tags `nodeTags' and their
 * corresponding master node tags `nodeTagsMaster', and the affine transform
 * `affineTransform' for the entity of dimension `dim' and tag `tag'. If
 * `includeHighOrderNodes' is set, include high-order nodes in the returned
 * data. */
GMSH_API void gmshModelMeshGetPeriodicNodes(const int dim,
                                            const int tag,
                                            int * tagMaster,
                                            size_t ** nodeTags, size_t * nodeTags_n,
                                            size_t ** nodeTagsMaster, size_t * nodeTagsMaster_n,
                                            double ** affineTransform, size_t * affineTransform_n,
                                            const int includeHighOrderNodes,
                                            int * ierr);


/* Get the maximum tag of entities of dimension `dim' in the built-in CAD
 * representation. */
GMSH_API int gmshModelGeoGetMaxTag(const int dim,
                                   int * ierr);

/* Set the maximum tag `maxTag' for entities of dimension `dim' in the built-
 * in CAD representation. */
GMSH_API void gmshModelGeoSetMaxTag(const int dim,
                                    const int maxTag,
                                    int * ierr);



/* Get the maximum tag of entities of dimension `dim' in the OpenCASCADE CAD
 * representation. */
GMSH_API int gmshModelOccGetMaxTag(const int dim,
                                   int * ierr);

/* Set the maximum tag `maxTag' for entities of dimension `dim' in the
 * OpenCASCADE CAD representation. */
GMSH_API void gmshModelOccSetMaxTag(const int dim,
                                    const int maxTag,
                                    int * ierr);


/* Imports an OpenCASCADE `shape' by providing a pointer to a native
 * OpenCASCADE `TopoDS_Shape' object (passed as a pointer to void). The
 * imported entities are returned in `outDimTags'. If the optional argument
 * `highestDimOnly' is set, only import the highest dimensional entities in
 * `shape'. For C and C++ only. Warning: this function is unsafe, as providing
 * an invalid pointer will lead to undefined behavior. */
GMSH_API void gmshModelOccImportShapesNativePointer(const void* shape,
    int** outDimTags, size_t* outDimTags_n,
    const int highestDimOnly,
    int* ierr);



/* Add a new post-processing view, with name `name'. If `tag' is positive use
 * it (and remove the view with that tag if it already exists), otherwise
 * associate a new tag. Return the view tag. */
GMSH_API int gmshViewAdd(const char * name,
                         const int tag,
                         int * ierr);

/* Remove the view with tag `tag'. */
GMSH_API void gmshViewRemove(const int tag,
                             int * ierr);

/* Get the index of the view with tag `tag' in the list of currently loaded
 * views. This dynamic index (it can change when views are removed) is used to
 * access view options. */
GMSH_API int gmshViewGetIndex(const int tag,
                              int * ierr);

/* Get the tags of all views. */
GMSH_API void gmshViewGetTags(int ** tags, size_t * tags_n,
                              int * ierr);

/* Add model-based post-processing data to the view with tag `tag'.
 * `modelName' identifies the model the data is attached to. `dataType'
 * specifies the type of data, currently either "NodeData", "ElementData" or
 * "ElementNodeData". `step' specifies the identifier (>= 0) of the data in a
 * sequence. `tags' gives the tags of the nodes or elements in the mesh to
 * which the data is associated. `data' is a vector of the same length as
 * `tags': each entry is the vector of double precision numbers representing
 * the data associated with the corresponding tag. The optional `time'
 * argument associate a time value with the data. `numComponents' gives the
 * number of data components (1 for scalar data, 3 for vector data, etc.) per
 * entity; if negative, it is automatically inferred (when possible) from the
 * input data. `partition' allows to specify data in several sub-sets. */
GMSH_API void gmshViewAddModelData(const int tag,
                                   const int step,
                                   const char * modelName,
                                   const char * dataType,
                                   size_t * tags, size_t tags_n,
                                   const double ** data, const size_t * data_n, size_t data_nn,
                                   const double time,
                                   const int numComponents,
                                   const int partition,
                                   int * ierr);

/* Add homogeneous model-based post-processing data to the view with tag
 * `tag'. The arguments have the same meaning as in `addModelData', except
 * that `data' is supposed to be homogeneous and is thus flattened in a single
 * vector. This is always possible e.g. for "NodeData" and "ElementData", but
 * only if data is associated to elements of the same type for
 * "ElementNodeData". */
GMSH_API void gmshViewAddHomogeneousModelData(const int tag,
                                              const int step,
                                              const char * modelName,
                                              const char * dataType,
                                              size_t * tags, size_t tags_n,
                                              double * data, size_t data_n,
                                              const double time,
                                              const int numComponents,
                                              const int partition,
                                              int * ierr);

/* Get model-based post-processing data from the view with tag `tag' at step
 * `step'. Return the `data' associated to the nodes or the elements with tags
 * `tags', as well as the `dataType' and the number of components
 * `numComponents'. */
GMSH_API void gmshViewGetModelData(const int tag,
                                   const int step,
                                   char ** dataType,
                                   size_t ** tags, size_t * tags_n,
                                   double *** data, size_t ** data_n, size_t *data_nn,
                                   double * time,
                                   int * numComponents,
                                   int * ierr);

/* Add list-based post-processing data to the view with tag `tag'. `dataType'
 * identifies the data: "SP" for scalar points, "VP", for vector points, etc.
 * `numEle' gives the number of elements in the data. `data' contains the data
 * for the `numEle' elements. */
GMSH_API void gmshViewAddListData(const int tag,
                                  const char * dataType,
                                  const int numEle,
                                  double * data, size_t data_n,
                                  int * ierr);

/* Get list-based post-processing data from the view with tag `tag'. Return
 * the types `dataTypes', the number of elements `numElements' for each data
 * type and the `data' for each data type. */
GMSH_API void gmshViewGetListData(const int tag,
                                  char *** dataType, size_t * dataType_n,
                                  int ** numElements, size_t * numElements_n,
                                  double *** data, size_t ** data_n, size_t *data_nn,
                                  int * ierr);

/* Add a string to a list-based post-processing view with tag `tag'. If
 * `coord' contains 3 coordinates the string is positioned in the 3D model
 * space ("3D string"); if it contains 2 coordinates it is positioned in the
 * 2D graphics viewport ("2D string"). `data' contains one or more (for
 * multistep views) strings. `style' contains pairs of styling parameters,
 * concatenated. */
GMSH_API void gmshViewAddListDataString(const int tag,
                                        double * coord, size_t coord_n,
                                        char ** data, size_t data_n,
                                        char ** style, size_t style_n,
                                        int * ierr);

/* Get list-based post-processing data strings (2D strings if `dim' = 2, 3D
 * strings if `dim' = 3) from the view with tag `tag'. Return the coordinates
 * in `coord', the strings in `data' and the styles in `style'. */
GMSH_API void gmshViewGetListDataStrings(const int tag,
                                         const int dim,
                                         double ** coord, size_t * coord_n,
                                         char *** data, size_t * data_n,
                                         char *** style, size_t * style_n,
                                         int * ierr);

/* Add a post-processing view as an `alias' of the reference view with tag
 * `refTag'. If `copyOptions' is set, copy the options of the reference view.
 * If `tag' is positive use it (and remove the view with that tag if it
 * already exists), otherwise associate a new tag. Return the view tag. */
GMSH_API int gmshViewAddAlias(const int refTag,
                              const int copyOptions,
                              const int tag,
                              int * ierr);

/* Copy the options from the view with tag `refTag' to the view with tag
 * `tag'. */
GMSH_API void gmshViewCopyOptions(const int refTag,
                                  const int tag,
                                  int * ierr);

/* Combine elements (if `what' == "elements") or steps (if `what' == "steps")
 * of all views (`how' == "all"), all visible views (`how' == "visible") or
 * all views having the same name (`how' == "name"). Remove original views if
 * `remove' is set. */
GMSH_API void gmshViewCombine(const char * what,
                              const char * how,
                              const int remove,
                              const int copyOptions,
                              int * ierr);

/* Probe the view `tag' for its `value' at point (`x', `y', `z'). Return only
 * the value at step `step' is `step' is positive. Return only values with
 * `numComp' if `numComp' is positive. Return the gradient of the `value' if
 * `gradient' is set. Probes with a geometrical tolerance (in the reference
 * unit cube) of `tolerance' if `tolerance' is not zero. Return the result
 * from the element described by its coordinates if `xElementCoord',
 * `yElementCoord' and `zElementCoord' are provided. */
GMSH_API void gmshViewProbe(const int tag,
                            const double x,
                            const double y,
                            const double z,
                            double ** value, size_t * value_n,
                            const int step,
                            const int numComp,
                            const int gradient,
                            const double tolerance,
                            double * xElemCoord, size_t xElemCoord_n,
                            double * yElemCoord, size_t yElemCoord_n,
                            double * zElemCoord, size_t zElemCoord_n,
                            int * ierr);

/* Write the view to a file `fileName'. The export format is determined by the
 * file extension. Append to the file if `append' is set. */
GMSH_API void gmshViewWrite(const int tag,
                            const char * fileName,
                            const int append,
                            int * ierr);




/* Set one or more parameters in the ONELAB database, encoded in `format'. */
GMSH_API void gmshOnelabSet(const char * data,
                            const char * format,
                            int * ierr);

/* Get all the parameters (or a single one if `name' is specified) from the
 * ONELAB database, encoded in `format'. */
GMSH_API void gmshOnelabGet(char ** data,
                            const char * name,
                            const char * format,
                            int * ierr);

/* Set the value of the number parameter `name' in the ONELAB database. Create
 * the parameter if it does not exist; update the value if the parameter
 * exists. */
GMSH_API void gmshOnelabSetNumber(const char * name,
                                  double * value, size_t value_n,
                                  int * ierr);

/* Set the value of the string parameter `name' in the ONELAB database. Create
 * the parameter if it does not exist; update the value if the parameter
 * exists. */
GMSH_API void gmshOnelabSetString(const char * name,
                                  char ** value, size_t value_n,
                                  int * ierr);

/* Get the value of the number parameter `name' from the ONELAB database.
 * Return an empty vector if the parameter does not exist. */
GMSH_API void gmshOnelabGetNumber(const char * name,
                                  double ** value, size_t * value_n,
                                  int * ierr);

/* Get the value of the string parameter `name' from the ONELAB database.
 * Return an empty vector if the parameter does not exist. */
GMSH_API void gmshOnelabGetString(const char * name,
                                  char *** value, size_t * value_n,
                                  int * ierr);

/* Clear the ONELAB database, or remove a single parameter if `name' is given. */
GMSH_API void gmshOnelabClear(const char * name,
                              int * ierr);

/* Run a ONELAB client. If `name' is provided, create a new ONELAB client with
 * name `name' and executes `command'. If not, try to run a client that might
 * be linked to the processed input files. */
GMSH_API void gmshOnelabRun(const char * name,
                            const char * command,
                            int * ierr);

#endif
